#84_Largest_Rectangle_in_Histogram

---

> * 问题
> * 代码
> * 思路

---

## 问题

84. 柱状图中最大的矩形给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

![](/84_Largest_Rectangle_in_Histogram.png)

以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。

![](/84_Largest_Rectangle_in_Histogram_area.png)

示例:

输入: [2,1,5,6,2,3]

输出: 10

## 代码

```python
class Solution:
    def largestRectangleArea(self, heights):
        """
        :type heights: List[int]
        :rtype: int
        """
        s = []
        ans = 0
        heights.append(0)

        for i in range(len(heights)):
            left_index = i
            while len(s) > 0 and s[-1][0] >= heights[i]:
                last = s.pop()
                # left_index这里用来记录本次遇到的低矩形可向前一直勾勒到第几的矩形，并在本次while循环后保存起来，便于下次比较
                left_index = last[1]
                ans = max(ans, heights[i] * (i + 1 - last[1]))
                ans = max(ans, last[0] * (i - last[1]))
            s.append((heights[i], left_index))
        return ans

if __name__ == '__main__':
    sl = Solution()
    rectangle = [2, 1, 5, 5,6, 2, 3]
    rec = [4, 2, 0, 3, 2, 5]
    res = sl.largestRectangleArea(rectangle)
    print(res)

```



##思路

 

思路：

​    我们可以看到，直方图矩形面积要最大的话，需要尽可能的使得连续的矩形多，并且最低一块的高度要高。有点像木桶原理一样，总是最低的那块板子决定桶的装水量。

那么既然需要用单调栈来做，首先要考虑到底用递增栈，还是用递减栈来做。我们想啊，递增栈是维护递增的顺序，当遇到小于栈顶元素的数就开始处理，而递减栈正好相反，

维护递减的顺序，当遇到大于栈顶元素的数开始处理。那么根据这道题的特点，我们需要按从高板子到低板子的顺序处理，先处理最高的板子，宽度为1，然后再处理旁边矮一些的板子，

此时长度为2，因为之前的高板子可组成矮板子的矩形 ，因此我们需要一个递增栈，当遇到大的数字直接进栈，而当遇到小于栈顶元素的数字时，就要取出栈顶元素进行处理了，

那取出的顺序就是从高板子到矮板子了，于是乎遇到的较小的数字只是一个触发，表示现在需要开始计算矩形面积了，为了使得最后一块板子也被处理，这里用了个小trick，

在高度数组最后面加上一个0，这样原先的最后一个板子也可以被处理了。由于栈顶元素是矩形的高度，那么关键就是求出来宽度，那么跟之前那道Trapping Rain Water一样，

单调栈中不能放高度，而是需要放坐标。由于我们先取出栈中最高的板子，那么就可以先算出长度为1的矩形面积了，然后再取下一个板子，此时根据矮板子的高度算长度为2的矩形面积，

以此类推，直到数字大于栈顶元素为止，再次进栈，巧妙的一比！

 

​    这里使用了单调栈，不过维护的是一个二维栈，每次保存柱形的高度和索引，便于比较，遇到大的柱子入栈，小的柱子开始运算。

比较从当前柱子依次向前(栈中已保存有递增二维序列)和前面柱子所能围成的各种图形的大小，保存最大的结果

 