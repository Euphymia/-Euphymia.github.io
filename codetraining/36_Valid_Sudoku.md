#36 Valid Sudoku

---

> * 问题
> * 代码
> * set的使用方法

---

## 问题

有效的数独

判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。

数字 1-9 在每一列只能出现一次。

数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

数独部分空格内已填入了数字，空白格用 '.' 表示。

示例 1:

输入:

[

​    ["5", "3", ".", ".", "7", ".", ".", ".", "."],

​    ["6", ".", ".", "1", "9", "5", ".", ".", "."],

​    [".", "9", "8", ".", ".", ".", ".", "6", "."],

​    ["8", ".", ".", ".", "6", ".", ".", ".", "3"],

​    ["4", ".", ".", "8", ".", "3", ".", ".", "1"],

​    ["7", ".", ".", ".", "2", ".", ".", ".", "6"],

​    [".", "6", ".", ".", ".", ".", "2", "8", "."],

​    [".", ".", ".", "4", "1", "9", ".", ".", "5"],

​    [".", ".", ".", ".", "8", ".", ".", "7", "9"]

]

输出: true

示例 2:

输入:

[

​    ["8", "3", ".", ".", "7", ".", ".", ".", "."],

​    ["6", ".", ".", "1", "9", "5", ".", ".", "."],

​    [".", "9", "8", ".", ".", ".", ".", "6", "."],

​    ["8", ".", ".", ".", "6", ".", ".", ".", "3"],

​    ["4", ".", ".", "8", ".", "3", ".", ".", "1"],

​    ["7", ".", ".", ".", "2", ".", ".", ".", "6"],

​    [".", "6", ".", ".", ".", ".", "2", "8", "."],

​    [".", ".", ".", "4", "1", "9", ".", ".", "5"],

​    [".", ".", ".", ".", "8", ".", ".", "7", "9"]

]

输出: false

解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。

​     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。

说明:

一个有效的数独（部分已被填充）不一定是可解的。

只需要根据以上规则，验证已经填入的数字是否有效即可。

给定数独序列只包含数字 1-9 和字符 '.' 。

给定数独永远是 9x9 形式的。

## 代码

```python
class Solution:
    def isValidSudoku(self, board):
        """
        :type board: List[List[str]]
        :rtype: bool
        """
        numset=set()
        for i in range(3):
            for j in range(3):
                numset.clear()
                for m in range(3):
                    for n in range(3):
                        if board[m+i*3][n+j*3] in numset and board[m+i*3][n+j*3]!=".":
                            return False
                        else: numset.add(board[m+i*3][n+j*3])
        for i in range(len(board)):
            numset.clear()
            for j in range(len(board[0])):
                if board[i][j] in numset and board[i][j] != ".":
                    return False
                else:numset.add(board[i][j])
        for i in range(len(board)):
            numset.clear()
            for j in range(len(board[0])):
                if board[j][i] in numset and board[j][i] != ".":
                    return False
                else:numset.add(board[j][i])
        return True
sl=Solution()
board1 = [
    ["8", "3", ".", ".", "7", ".", ".", ".", "."],
    ["6", ".", ".", "1", "9", "5", ".", ".", "."],
    [".", "9", "8", ".", ".", ".", ".", "6", "."],
    ["8", ".", ".", ".", "6", ".", ".", ".", "3"],
    ["4", ".", ".", "8", ".", "3", ".", ".", "1"],
    ["7", ".", ".", ".", "2", ".", ".", ".", "6"],
    [".", "6", ".", ".", ".", ".", "2", "8", "."],
    [".", ".", ".", "4", "1", "9", ".", ".", "5"],
    [".", ".", ".", ".", "8", ".", ".", "7", "9"]
]
board2 =[
    ["5", "3", ".", ".", "7", ".", ".", ".", "."],
  ["6", ".", ".", "1", "9", "5", ".", ".", "."],
  [".", "9", "8", ".", ".", ".", ".", "6", "."],
  ["8", ".", ".", ".", "6", ".", ".", ".", "3"],
  ["4", ".", ".", "8", ".", "3", ".", ".", "1"],
  ["7", ".", ".", ".", "2", ".", ".", ".", "6"],
  [".", "6", ".", ".", ".", ".", "2", "8", "."],
  [".", ".", ".", "4", "1", "9", ".", ".", "5"],
  [".", ".", ".", ".", "8", ".", ".", "7", "9"]
]
res=sl.isValidSudoku(board2)
print(res)
```

## set的使用方法

```python
# set 无序，不重复序列
# 创建
# 第一种
set1 = {"1", "2"}
# {'1', '2'}
print(type(set1))
# 第二种
list1 = ["1", "2", "2", "1"]
set2 = set(list1)
print(set2)
# {'1', '2'}
# <class 'set'>
# 功能
# 添加一个元素
s = set()
s.add(123)
s.add(123)
print(s)
# {123}
# 清除素有内容
s.clear()
print(s)
# set()
# 两个集合的差集
s1 = {32, 12, 34}
s2 = {12, 43, 23}
# s1中存在，s2中不存在
print(s1.difference(s2))
# {32, 34}
# 对称差集
print(s1.symmetric_difference(s2))
# {32, 34, 43, 23}
# difference和symmetric_different会生成新一个结果，而different_update 和 symmetic_different_update会覆盖之前集合

# 移除元素 如果元素不存在，不会报错 remove 如果元素不存在，会报错
s1.discard(32)
print(s1)
# {34, 12}
# 集合pop随机移除某个元素并且获取那个参数,集合pop没有参数
re2 = s2.pop()
print(re2)
# 43
s3 = {11, 22, 33}
s4 = {44, 33, 22}
# 交集
print(s3.intersection(s4))
# {33, 22}

# 判断两个集合有没有交集,有返回true 无返回false
print(s3)
print(s4)
print(s3.isdisjoint(s4))
# False 怎么是false 这不是有交集吗

# 并集
print(s3.union(s4))
# {33, 22, 11, 44}

# update 批量更新
li = [21, 4, 2, 312]
s3.update(li)
print(s3)
# {33, 2, 4, 11, 21, 22, 312}
```

