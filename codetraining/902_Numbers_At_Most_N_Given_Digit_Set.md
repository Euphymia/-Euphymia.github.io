#Numbers_At_Most_N_Given_Digit_Set

------

> - 问题
> - 代码
> - 思路

## 问题

最大为 N 的数字组合



我们有一组排序的数字 D，它是  {'1', '2', '3', '4', '5', '6', '7', '8', '9'} 的非空子集。（请注意，'0' 不包括在内。）

现在，我们用这些数字进行组合写数字，想用多少次就用多少次。例如 D = {'1', '3', '5'}，我们可以写出像 '13', '551', '1351315' 这样的数字。

返回可以用 D 中的数字写出的小于或等于 N 的正整数的数目。

示例 1：

输入：D = ["1", "3", "5", "7"], N = 100

输出：20

解释：

可写出的 20 个数字是：

1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.

示例 2：

输入：D = ["1", "4", "9"], N = 1000000000

输出：29523

解释：

我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，

81 个四位数字，243 个五位数字，729 个六位数字，

2187 个七位数字，6561 个八位数字和 19683 个九位数字。

总共，可以使用D中的数字写出 29523 个整数。

提示：

 

D 是按排序顺序的数字 '1'-'9' 的子集。

1 <= N <= 10 ^ 9

 

## 代码

```python
class Solution:
    def atMostNGivenDigitSet(self, D, N):
        N = str(N)
        n = len(N)
        res = sum(len(D) ** i for i in range(1, n))
        i = 0
        while i < len(N):
            res += sum((c < N[i])* (len(D) ** (n - i - 1)) for c in D)
            if N[i] not in D:
                break
            i += 1
        return res + (i == n)

if __name__=="__main__":
    D = ["1", "3", "5", "7"]
    N=7000
    sl=Solution()
    print(sl.atMostNGivenDigitSet(D,N))
```

## 思路

思路：

极好的答案

首先计算出所有小于目标值位数的可能存在的组合个数

然后开始计算与目标位数相等的组合的个数

从最高位开始，挑选小于最高位的数字并计算可能存在的后续低位组合的个数，如果最高位的数字不存在于D中。 

则结束循环，如果存在则说明还可能有其他组合，开始找小于目标值第二位的数字，并计算后续地位组合的个数，以此类推。

最终计算出可能的总个数。